# 콘솔이라는 작은 시작

## 그럽은 아직 끝나지 않았다

그럽은 특정 조건을 만족해야 실행을 시켜준다. 어쩔 수 없으니 알고있자. 

- 커널 파일에서 80KB부분을 검색한다
- 그래서 특정 시그니쳐를 찾아낸다.

    - 이 시그니쳐를 *멀티부트 헤더 구조체*라고 하는데 부팅 하는데 필요한 헤더라는 의미같다. (잘 모르겠으니까 알면 풀리퀘ㄱㄱ)

```c++
_declspec(naked) void multiboot_entry(void)
{
	__asm {
		align 4

		multiboot_header:
		//멀티부트 헤더 사이즈 : 0X20

        //dd는 define double word를 뜻하는 매크로다. 4바이트 데이터 공간을 확보한다.

		dd(MULTIBOOT_HEADER_MAGIC); magic number
		dd(MULTIBOOT_HEADER_FLAGS); flags
		dd(CHECKSUM); checksum
		dd(HEADER_ADRESS); //헤더 주소 KERNEL_LOAD_ADDRESS+ALIGN(0x100064)
		dd(KERNEL_LOAD_ADDRESS); //커널이 로드된 가상주소 공간
		dd(00); //사용되지 않음
		dd(00); //사용되지 않음
		dd(HEADER_ADRESS + 0x20); //커널 시작 주소 : 멀티부트 헤더 주소 + 0x20, kernel_entry
			
		kernel_entry :
	}
}

```
여기서 dd가 뭐하는건지는 [여기 강의](http://www.cs.virginia.edu/~evans/cs216/guides/x86.html)를 잘 찾아보면 되니까 알아서 공부하면 좋아

여기서 고수들은 알 수도 있는데 multiboot_entry가 바로 함수이다. 근데 특이한 함수라서 원래는 실행이 안된다. 함수 초반이 데이터이기 때문이란다. 그러니까 실행코드가 없다. 어차피 함수는 main만 실행되면 끝이니까 여기는 대강 넘어가자. 이걸 구조체라고도 할 수 있다는데 그 이유가 naked라고 써서 그렇다고 한다.

그럽은 특정 시그니쳐를 찾고 그걸로 커널임을 판단하는데 
```c
#define MULTIBOOT_HEADER_MAGIC         0x1BADB002
```
이것이다. 이걸 dd로 넣어주면 되는거다.

그다음에는 엔트리포인트를 실행한다. kernel_entry:레이블부터라는데 이 아래부터 커널의 실제 코드이다. 우리는 kmain에 멀티부트의 정보를 담은 구조체를 보내준다. 이 구조체는 
```c++
struct MULTIBOOT_HEADER {
	uint32_t magic;
	uint32_t flags;
	uint32_t checksum;
	uint32_t header_addr;
	uint32_t load_addr;
	uint32_t load_end_addr;
	uint32_t bss_end_addr;
	
    uint32_t entry_addr; //HEADER_ADDRESS + 0x20
    //시작지점
};
```
HEADER_ADDRESS는 많이 쓰이는 놈이라고 생각된다. 설명이 뭐가 계속 나와. 그나저나 KERNEL_LOAD_ADDRESS + ALIGN 이렇단다. 

- KERNEL_LOAD_ADDRESS
    - 커널 로드지점
    - 0X100000 영역
- ALIGN
    - 0x400이래
    - 얘는 로드지점에서 떨어진 정도를 나타내는듯. 
    - 0이 안되는 이유는 먼저 나와야 하는 애들이 있어서

<h3>중요하다길래 강조하겠음</h3>
multiboot_entry 얘가 80KB안에 있어야 하니까 0X100400에 위치되야 하는게 중요하대. 어디든 있어도 되지만 우리는 GRUB을 쓰기때문에 제약이 있음. 그래서 우린 비주얼 스튜디오의 옵션을 써서 함수안의 함수등장 순번을 조정가능함. 그런데 우리는 이미 설정이 끝난 상태니까 괜찮다. 확인을 하는 방법은 order.txt파일에 ?multiboot_entry@@YAXXZ 이렇게 쓰여있대. 이렇게 등록을 하면 파일 선두에 배치가 가능함. 이걸로 함수들을 정렬도 가능하다. 
함수 이름이 <?multiboot_entry@@YAXXZ> 이따위인 이유는 C++네임 맹글링때문이라는데 나는 넘어간 부분이라서 나중에 봐야겠다. 그니까 함수 이름이 컴파일이나 링킹하다가 바뀐다는거다. 어떻게 바뀌는지는 map파일로 볼 수 있는데 어차피 이거말고는 딱히 안볼 것 같아서 PASS

```assembly
kernel_entry :
    mov     esp, KERNEL_STACK; //스택 설정, 0x0040000

    push    0; //플래그 레지스터 초기화
    popf

    //GRUB에 의해 담겨 있는 정보값을 스택에 푸쉬한다.
    push    ebx; //멀티부트 구조체 포인터
    push    eax; //매직 넘버

    //위의 두 파라메터와 함께 kmain 함수를 호출한다.
    call    kmain; //C++ 메인 함수 호출

    //루프를 돈다. kmain이 리턴되지 않으면 아래 코드는 수행되지 않는다.
    halt:
    jmp halt;
```
엔트리(실제커널)의 어셈블리는 이렇다. 일단 첫 줄에서 스택을 어디서 쓸건지 설정하는데 적당히 잡아준다. 커널 영역과 섞이지 않으며, 전체 크기도 고려한다(우리는 1MB)
두번째 줄에는 레지스터 초기화이다. EFLAGS 래지스터를 초기화 한다.
그다음 줄들에서는 파라미터를 넘기고, 이걸 kmain이 받는다. 둘다 필요한 주소들의 값이다.