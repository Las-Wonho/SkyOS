# 그럼그럽
(실패한 드립..)
<p>
우리가 편하게 코딩이 가능한 이유는 바로 GRUB덕분이다. (물론 이미 프로젝트 내부에서 사전작업을 한 것도 이유이지만)
일단 이게 뭔지는 책에 자세하게 나와있고 위키를 보던지 하자. 쓰기가 귀찮다.

## 그래서 뭐?

이걸 써서 운영체제를 부팅 할 것이다. 막 어셈까지 많이 하지 않아도 OK라는 것이다. 그리고 이건 우분투에서도 쓰이기 때문에 어느정도 보편적이고 믿을 만 한 시스템이라는 것이다. (인기없는건 유지보수도 안되니...)
그래서 여기서 부팅이 되면 Goocl!
<p>
게다가 이건 여러 컴퓨터에서 실행을 시켜주기때문에 더 편하다. 네가 컴퓨터 하나에만 맞는 운영체제를 만들건 아니잖아? (맥은...?)

## 부팅방법을 살펴보자!

여기서부터는 화나는 로우레벨이다. 어쩔 수 없다. 운영체제를 만들려면 *Row*레벨을 해야한다. 그래도 직접 만들진 않았으니 다행으로 생각하고 체념하자.

- MBR을 읽어온다! 
    - (메모리 버퍼 리더가 아니다. 근데 약자는 같네? 젠장.)
    
- MBR에 1번 스테이지는 1.5나 2를 불러온다  
    - (뭔 *Mal*소리지?)

- 1.5는 MBR다음의 30KB에 저장되며 2를 불러온다 
    - (그래서 목표는 2번부르기?)

- 2는 부트메뉴나 프롬프트를 보여줌 
    - (이게 목표였구만)

- 커널을 메모리에 적재시킨다. 
    - (실행하려면 필수)

- 커널의 엔트리를 실행한다. 
    - 드디어 ㅅ ㅣ ㄹ ㅎ ㅐ ㅇ!

(얘가 부트로더역할까지 다 한대. 역시 편함)

- boot.img
    - 그니까 여기서 부팅

- core.img
    - 코드 실행

- grub.cfg + 커널들 불러옴

## 설치

알아서 하셈.

## 실행

일단 QEMU에서 먼저 테스트 해보셈. 잘못건들어서 죽기 싫잖아?
그니까 QEMU에서 실행하셈

### QEMU에서 실행(GRUB시러)

기본적인 배치파일 다 만들어놨으니 그거보셈! 어차피 실행자체는 제공해준다. 즉, 우리가 그렇게 신경 쓸 필요 없다는거!

### 실행할 때의 파라메터

이걸 굳이 알 필요는 없지만 우리는 흑마법을 쓰기 때문에 알아두면 좋을 듯 하다.
일단 레거시때문에 16비트로 부팅이 된다. (윈도우처럼 호환을 중요시하나봐)
그래도 적당히 쓸 명령은 있는데 진짜 거기서만 만들거는 아니잖아? 
그런데 여기서 우리의 악마이자 천사인 *그럽*이 정보만 얻고 보호모드로 전환한다. 그래서 보호모드는 32비트 쓸 수 있으니까 써야한다는 거다. 4GB정도 접근이 가능 하다는데...
