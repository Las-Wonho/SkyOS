# 그럼그럽
(실패한 드립..)
<p>
우리가 편하게 코딩이 가능한 이유는 바로 GRUB덕분이다. (물론 이미 프로젝트 내부에서 사전작업을 한 것도 이유이지만)
일단 이게 뭔지는 책에 자세하게 나와있고 위키를 보던지 하자. 쓰기가 귀찮다.

## 그래서 뭐?

이걸 써서 운영체제를 부팅 할 것이다. 막 어셈까지 많이 하지 않아도 OK라는 것이다. 그리고 이건 우분투에서도 쓰이기 때문에 어느정도 보편적이고 믿을 만 한 시스템이라는 것이다. (인기없는건 유지보수도 안되니...)
그래서 여기서 부팅이 되면 Goocl!
<p>
게다가 이건 여러 컴퓨터에서 실행을 시켜주기때문에 더 편하다. 네가 컴퓨터 하나에만 맞는 운영체제를 만들건 아니잖아? (맥은...?)

## 부팅방법을 살펴보자!

여기서부터는 화나는 로우레벨이다. 어쩔 수 없다. 운영체제를 만들려면 *Row*레벨을 해야한다. 그래도 직접 만들진 않았으니 다행으로 생각하고 체념하자.

- MBR을 읽어온다! 
    - (메모리 버퍼 리더가 아니다. 근데 약자는 같네? 젠장.)
    
- MBR에 1번 스테이지는 1.5나 2를 불러온다  
    - (뭔 *Mal*소리지?)

- 1.5는 MBR다음의 30KB에 저장되며 2를 불러온다 
    - (그래서 목표는 2번부르기?)

- 2는 부트메뉴나 프롬프트를 보여줌 
    - (이게 목표였구만)

- 커널을 메모리에 적재시킨다. 
    - (실행하려면 필수)

- 커널의 엔트리를 실행한다. 
    - 드디어 ㅅ ㅣ ㄹ ㅎ ㅐ ㅇ!

(얘가 부트로더역할까지 다 한대. 역시 편함)

- boot.img
    - 그니까 여기서 부팅

- core.img
    - 코드 실행

- grub.cfg + 커널들 불러옴

## 설치

알아서 하셈.

## 실행

일단 QEMU에서 먼저 테스트 해보셈. 잘못건들어서 죽기 싫잖아?
그니까 QEMU에서 실행하셈

### QEMU에서 실행(GRUB시러)

기본적인 배치파일 다 만들어놨으니 그거보셈! 어차피 실행자체는 제공해준다. 즉, 우리가 그렇게 신경 쓸 필요 없다는거!

### 실행할 때의 파라메터

이걸 굳이 알 필요는 없지만 우리는 흑마법을 쓰기 때문에 알아두면 좋을 듯 하다.
일단 레거시때문에 16비트로 부팅이 된다. (윈도우처럼 호환을 중요시하나봐)
그래도 적당히 쓸 명령은 있는데 진짜 거기서만 만들거는 아니잖아? 
그런데 여기서 우리의 악마이자 천사인 *그럽*이 정보만 얻고 보호모드로 전환한다. 그래서 보호모드는 32비트 쓸 수 있으니까 써야한다는 거다. 4GB정도 접근이 가능 하다는데...

근데 여기서 *그럽*이 얻은 정보를 우리가 받아야 하잖아? 그래서 이걸 구조체로 받는거야. 나중에 또 받으려면 많이 귀찮대. 

```C++
        uint32_t flags; //플래그. 플래그값을 확인해서 VESA 모드가 가능한지의 여부를 파악할 수 있다.
	//바이오스로부터 얻은 이용가능한 메모리 영역 정보
	uint32_t mem_lower;
	uint32_t mem_upper;
 
	uint32_t boot_device; //부팅 디바이스의 번호
	char *cmdline; //커널에 넘기는 커맨드라인

        //부팅 모듈 리스트
	uint32_t mods_count;
	Module *Modules;
	//리눅스 파일과 관계된 정보
	union
	{
		AOUTSymbolTable AOUTTable;
		ELFHeaderTable ELFTable;
	} SymbolTables;
 
	//메모리 매핑 정보를 알려준다. 이 정보를 통해 메모리 특정 블록을 사용할 수 있는지 파악가능하다.
	uint32_t mmap_length;
	uint32_t mmap_addr;
 
	//해당 PC에 존재하는 드라이브에 대한 정보
	uint32_t drives_length;
	drive_info * drives_addr;
 
	// ROM configuration table 
	ROMConfigurationTable *ConfigTable;
 
	//부트로더 이름
	char* boot_loader_name;
 
	// APM table 
	APMTable *APMTable;
 
	//비디오
	VbeInfoBlock *vbe_control_info;
	VbeModeInfo *vbe_mode_info;
	uint16_t vbe_mode;
	uint16_t vbe_interface_seg;
	uint16_t vbe_interface_off;
	uint16_t vbe_interface_len;

```
이런 정보들이 우리에게 들어오게된다. 이런 귀찮은 것들을 그럽이라는 애가 대신해준다.